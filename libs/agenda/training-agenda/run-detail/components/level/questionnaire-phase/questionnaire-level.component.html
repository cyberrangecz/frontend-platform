@let isBacktracked = runService.runInfo$.observeProperty().isBacktracked.$() | async;
@let isLast = runService.runInfo$.observeProperty().isLastLevelDisplayed.$() | async;
<div class="container">
    <div class="level-content">
        @for (question of (phase$ | async).questions; track question; let i = $index) {
            <div class="questions">
                <h2>{{ i + 1 }}. {{ question.text }}</h2>
                @if (question.answerRequired && !isBacktracked) {
                    <p class="required-note">Answer required</p>
                }
                @switch (question.questionType) {
                    @case (questionTypes.FFQ) {
                        <div class="question">
                            <mat-form-field appearance="outline">
                                <mat-label> Answer</mat-label>
                                <input [(ngModel)]="questionAnswers[i].answers[0]"
                                       [disabled]="isBacktracked"
                                       [maxLength]="1023"
                                       [required]="question.answerRequired"
                                       matInput
                                />
                            </mat-form-field>
                            @if (questionAnswers[i].answers[0] && questionAnswers[i].answers[0].length === 1023) {
                                <mat-error
                                    id="max-length-ffq-answer"
                                >
                                    * You have reached the maximal size of message. If you wish to write longer message,
                                    please
                                    contact your
                                    administrator.
                                </mat-error>
                            }
                        </div>
                    }
                    @case (questionTypes.MCQ) {
                        <div class="mcq-question">
                            @for (choice of question.choices; track choice) {
                                <div>
                                    <mat-checkbox
                                        (change)="onMCQChecked($event, i, choice.text)"
                                        [checked]="checkedAsAnswered(question, choice)"
                                        [disabled]="isBacktracked"
                                        [required]="question.answerRequired"
                                    />
                                    <p class="mcq-answer">{{ choice.text }}</p>
                                </div>
                            }
                        </div>
                    }
                    @case (questionTypes.RFQ) {
                        <div class="rfq-question">
                            @for (choice of question.choices; track choice) {
                                <div class="rfq-answer">
                                    <mat-checkbox
                                        (change)="onRFQChecked($event, i, choice.text)"
                                        [checked]="checkedAsAnswered(question, choice)"
                                        [disabled]="isBacktracked"
                                        [required]="question.answerRequired"
                                    />
                                    <p>{{ choice.text }}</p>
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        }
    </div>
    <!-- Differentiate submit action by different button style -->
    @if (isBacktracked) {
        <button
            (click)="onNext()"
            class="confirm-button"
            mat-raised-button>
            Next
        </button>
    } @else {
        <button
            (click)="submit()"
            [disabled]="!canSubmit()"
            class="confirm-button"
            mat-flat-button>
            {{ isLast ? "Finish" : "Submit" }}
        </button>
    }
</div>
